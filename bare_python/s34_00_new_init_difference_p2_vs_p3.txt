The difference between Python 2.x and Python 3.x in terms of __new__ and __init__ boils down to the difference of their behaviour in "old-style" and "new-style" classes as called in Python 2.

The ideea is that "old-style" mean in Python 2 that you would define a class simply with `class A` whereas the "new-style" meant defining it with "class A(object)". The key difference is that in Python 2, the old-style class was inheriting dirrectly from `type` whereas the new-style mean it was using some new functionality defined in `object` that altered the behaviour of __new__ and __init__.

In Python 3 there is no more such thing as "old-style" and "new-style", and everytime you would define `class A` in Python 3, it's actually the equivalent of the new-style from Python 2.

In old-style:
- there is not __new__ because __init__ is the constructor
- __init__ must always return None

which basically means that in the (very) old way of declaring a class
you were not able to control the result of object creation,
whereas in the new-style and Python 3 exclusively:
- __new__ can return something
- __init__ is always called (by Pythonic magic) on the instance returned by __new__, which basically means that if you return a number, the __init__ will be called on that number.
- __init__ must always return None (things never change)

s34_01 depicts the behvaiour of __new__ and __init__ in Python 2

s34_02 depicts the behvaiour of __new__ and __init__ in Python 3